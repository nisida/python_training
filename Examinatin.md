## まとめ演習
---------------------------

### プログラムファイルの作成、実行
VSCodeを使って、

```python
print("Hello module world!")
```

 というコードだけを収めた簡単なモ
ジュールファイルを作成してください。ファイル名はmodule1.py にします。モジュールファイルが
できたら、何らかの方法（IDLE を使用する、アイコンをクリックする、python module1.py といっ
たシステムシェルのコマンドラインでファイル名を入力する、など）でファイル中のプログラムを起
動してください。できれば、この章で紹介した方法をすべて使ってみてください。どの方法が最も「や
さしい」と感じたでしょうか（もちろん、この問いには唯一の正解はありません）。

### モジュールのインポート
Python の対話型コマンドラインを起動し（>>> プロンプトが表示された状態にし）、演習問題2 で作
成したモジュールをインポートしてください。その後、モジュールファイルを別のディレクトリに移
動して、同じように（ファイルが移動されていないものとして）再度インポートをしてみてください。
結果はどうなるでしょうか（ヒント：元のディレクトリにmodule1.pyc というファイルはあるでしょ
うか）。

### 実行可能スクリプトの作成
UNIXやLinux、あるいはMac OS Xなども含めたUNIX系システムを使用している人は、module1.pyファ
イルの先頭に#! で始まる行を追加し、ファイルに実行権限を指定して、実行可能スクリプトにして
から起動してみてください。先頭の行にはどのような記述が必要でしょうか。Windows マシンを使
用している人はこの演習は飛ばしてかまいません（Windows では、この種の実行可能スクリプトが
サポートされていません）。その代わりに、DOS コンソールウィンドウでモジュールファイルの名前
のみを入力して起動する（新しいバージョンのWindows を使用している場合のみ）、または［スタート］
－［ファイル名を指定して実行］ダイアログボックスにモジュールファイル名を指定して起動すると
いった演習をしてください。

## まとめ演習
---------------------------

### 基本的な操作
個々の型のオブジェクトについて、基本的な操作（II 部の中で表にまとめられているもの）を、対話
型コマンドラインで実際に行ってください。まず、VSCodeのセルを起動して、以下に示した
式を入力して実行し、結果を確かめます。それぞれ、なぜその結果になったのかを自分で説明できる
かも確認してください。

```python
2 ** 16
2 / 5, 2 / 5.0

"spam" + "eggs"
S = "ham"
"eggs " + S
S * 5
S[:0]
"green %s and %s" % ("eggs", S)

('x',)[0]
('x', 'y')[1]

L = [1,2,3] + [4,5,6]
L, L[:], L[:0], L[-2], L[-2:]
([1,2,3] + [4,5,6])[2:4]
[L[2], L[3]]
L.reverse(); L
L.sort(); L
L.index(4)

{'a':1,'b':2}['b']
D = {'x':1, 'y':2, 'z':3}
D['w'] = 0
D['x'] + D['w']
D[(1,2,3)] = 4
D.keys(), D.values(), D.has_key((1,2,3))

[[]], ["",[],(),{},None]

```

### インデクシングとスライシング
VSCodeのセルで、4 つの文字列、あるいは数値からなるリストを作成し、変数L に代入しま
す（例：L=[0,1,2,3]）。その後、以下の操作をして、結果を確認してください。いずれも、いわゆ
る「境界条件」での操作です。操作の前には結果の予測もしてください。

a. 存在しないオフセットを指定してインデクシングを行う（例：L[4]）。
b. 存在しないオフセットを指定してスライシングを行う（例：L[-1000:100]）。
c. 通常とは逆に、開始位置のオフセットを終了位置のオフセットより大きくしてスライシングを行う（例：L[3:1]）。

このスライシングと値の代入の組み合わせも行ってみる（例：L[3:1]=['?']）。
この場合、どこに新規の値が追加されるかを確かめること。存在しないオフセッ
トを指定してのスライシングと結果がどのように異なるかの比較も行う。

### インデクシング、スライシングと del ステートメント
4 つの要素からなるリストを再度作成し、変数L に代入した後、いずれかのオフセットを指定して空
のリストを代入します（例：L[2]=[]）。次に、スライシングによって指定した範囲に空のリストを
代入します（例：L[2:3]=[]）。それぞれ結果がどのようになるかを確認してください。すでに解説
したとおり、スライシングで範囲を指定して値を代入する場合には、まず該当する範囲の要素は削除
され、その後に新しい要素が挿入されることになります。
オフセット、キーを指定しての要素の削除、あるいはスライシングによって範囲を指定しての要素の
削除には、del ステートメントも使用できます（del ステートメントは属性、変数の削除にも使用で
きます）。この演習でも、del ステートメントによる要素の削除を実際に行ってみてください（例：
del L[0]）。del L[0:] のように書けば、リストの全要素を削除することも可能です。その他、ス
ライシングによって指定した範囲にシーケンスでないオブジェクトを代入しようとしたときの結果が
どのようになるかも確認してください（例：L[1:2]=1）。

### タプルによる値の代入
以下のコードを実行した場合、X とY にどのようなことが起きるかを予測してください。

```python
>>> X = 'spam'
>>> Y = 'eggs'
>>> X, Y = Y, X
```

### ディクショナリのキー
まず、以下のコードを実行してください。

```python
>>> D = {}
>>> D[1] = 'a'
>>> D[2] = 'b'
```

ディクショナリでは要素へのアクセスにオフセットではなくキーを使うはずですが、このコードが問
題なく実行できるのはなぜでしょうか。その理由を考えてください。以下のコードが問題なく実行で
きる、というのがヒントになるかもしれません（整数、数値、タプルに共通する性質は何でしょうか）。

```python
>>> D[(1, 2, 3)] = 'c'
>>> D
{1: 'a', 2: 'b', (1, 2, 3): 'c'}
```

### ディクショナリのインデクシング
まず、3 つの要素を持つディクショナリを作成し、変数D に代入します。要素のキーはそれぞれ、
'a'、'b'、'c' にします。そして次に、存在しないキー'd' を指定してインデクシングを行います（例：
D['d']）。結果はどのようになるでしょうか。予測してみてください。リストで存在しないキーを指
定して値の代入や抽出を行った場合と比べてどのように違うでしょうか。また、存在しない変数名を
使用する場合の規則と、存在しないキーを使用する場合の規則は似ているでしょうか。それともまっ
たく異なっているでしょうか。


### オブジェクトの操作に関する質問
以下のa～d の問いに答えてください。

a. + 演算子で型の異なるオブジェクトを連結しようとすると、結果はどのようになるか（文字列+リスト、リスト+ タプル、など）。
b. + 演算子は、オペランドの少なくとも一方がディクショナリである場合に正しく機能するか。
c. append メソッドは、リストと文字列のうち、どちらに使用できるメソッドか（ヒント：append
メソッドの処理対象となるオブジェクトがどのような性質のものでなければならないかを考える
とわかる）。keys メソッドはリストに使用できるか。
d. リスト、文字列に対してスライシングや連結の操作を行った場合、戻り値として得られるオブジェ
クトの型はどのようになるか。

### 文字列のインデクシング
まず、4 文字からなる文字列を作成し、変数S に代入してください（S = "spam" というコードを実
行します）。そして次に、S[0][0][0][0][0] というコードを実行します。結果はどのようなものに
なるでしょうか（ヒント：文字列は「文字の集合」ですが、Python の場合、個々の文字も「1 文字か
ら構成される文字列オブジェクト」として扱われます）。また、S[0][0][0][0][0] というインデクスを
['s', ]'p', 'a', 'm'] というリストに対しては使えるでしょうか。使える（あるいは使えない）理由も考えてください。

### 不変性オブジェクト
再びS = "spam" というコードで、変数S に4 文字からなる文字列を代入します。その後、文字列を
"slam" に変更するコードを書きます。インデクシング、スライシング、連結を使って、あるいはイ
ンデクシングと連結だけで、このコードを書いてみてください。また、インデックスによる位置の指
定と値の代入で、このコードが書けるかも考えてください。

### ネスト
読者の名前（姓、名）、年齢、職業、住所、メールアドレス、電話番号などをひとまとめにして扱えるデー
タ構造を作ってください。ビルトインオブジェクトであれば、リスト、タプル、ディクショナリ、文
字列、数値など、どのような型のものを何種類使用してもかまいません。データ構造ができたら、個々
の要素に、インデクシングによってアクセスしてみてください。また、できれば1 つ作っただけで満
足せずに、さらによいものができないかを検討してみてください。

### ファイル
まず、「myfile.txt というファイルを作成し、その中に“Hello file world!”と書き込む」という機能を
持つプログラムを作成します。次に、「myfile.txt ファイルを開き、その内容を読み込んで出力する」
という機能を持ったプログラムを作成します。2 つのプログラムができたら、システムのコマンドラ
インで実行してください。プログラム実行後は、実行に使用したディレクトリに新しいファイルが作
成されているかを確認し、作成するファイルのパスを変更するにはどうすればよいかも考えてみてく
ださい。   

注意：ファイルへの書き込みを行うメソッドには、引数に指定された文字列に改行文字を自動で追加
する機能はないので、書き込む文字列の末尾に改行文字を入れたい場合は、プログラマが明示的に指
定する必要があります。

### dir 関数
以下に示したコードをVSCodeのセルで実行してください。dir 関数（この関数についてはI
部でも触れています）はPython のバージョン1.5 から導入されたもので、引数に指定されたPython
オブジェクトの属性のリストを表示する機能を備えています。本書ですでに紹介したようなオブジェ
クトであれば、ほぼどれを指定しても対応できます。1.5 より前のバージョンでは、
__methods__をdir と同じ目的で使用していました。Python 2.2 では、dir のみが使えるようになっているはずで
す。

```python
[].__method__ # 1.4、あるいは 1.5
dir([]) # 1.5 以降

{}.__method__ methods # ディクショナリの属性
dir({})

```

## まとめ演習

### 簡単なループのコードを書く
a. 変数S に代入された文字列を構成する個々の文字のASCII コードを出力するループ。ビルトイン関
数ord を使用する。これは、引数として指定された文字のASCII コード（整数）を戻す関数（まず、
VSCodeのセルで関数の機能を確認するとよい）。
b. a のループを、文字列を構成する個々の文字のASCII コードをすべて足し合わせ、その合計を得る、
というものに変える。
c. b のループを、文字列を構成する個々の文字のASCII コードを要素とするリストを作成する、とい
うものに変え、map(ord, S) と書いた場合と同様の結果が得られるようにする。

### バックスラッシュ
以下のコードをVSCodeのセルで実行し、どのような結果が得られるかを確かめてください。
　　　for i in range(50):
　　　　　print 'hello %d\n\a' % i
このコードをIDLE 以外で実行する場合は注意が必要です。コンピュータからビープ音が出る恐れが
あるので、人の多いオフィスなどでは実行しない方がよいでしょう。IDLE で実行した場合には、ビー
プ音が出る代わりに意味のない文字が出力されるだけです（バックスラッシュを使用したエスケープ
シーケンスについては表7-2 を参照してください）。

### ディクショナリのソート
8 章で触れたとおり、ディクショナリは、オブジェクトを順不同で並べたものです。ここでは、ディ
クショナリの要素を昇順にソートして1つずつ出力する、というループを書いてください。ヒント：ディ
クショナリのkeys メソッドとリストのsort メソッド、あるいは新たに導入されたビルトイン関数
sorted を使用します。

### プログラムを書き直す
まず、以下のコードを見てください。これはwhile ループとフラグ（found）を使用して、2 のべき
乗のリストから2 の5 乗（32）を探す、というコードです。コードはpower.py というモジュールファ
イルに収めるものとします。

```python
L = [1, 2, 4, 8, 16, 32, 64]
X = 5

found = i = 0
while not found and i < len(L):
　　　　if 2 ** X == L[i]:
　　　　　　found = 1
　　　　else:
　　　　　　i = i+1
if found:
　　print('at index', i)
else:
   print(X, 'not found')

C:python power.py
at index 5

````

このコードは、Python のプログラミングの常識に照らすと、あまりよいとは言えないものになって
います。a～e の指示に従って改良してください。改良コードはVSCodeのに入力しても、
ファイルに入力してもかまいません。ファイルにコードを収めた場合にはシステムのコマンドライン
で実行することになります（ファイルにコードを入力した方が、この演習は進めやすいはずです）。
a. found フラグと2 つ目のif ステートメントが不要になるよう、while ループにelse ブロックを加
える。
b. リストのインデクシングのコードが不要になるよう、for ループを使用する。for ループでは
else ブロックも使用する。ヒント：リストのindex メソッドを使用すれば、要素のインデックス
を得ることができる（L.index(X) と書けば、リストL の要素X のオフセットが得られる）。
c. ループを使用するのをやめ、要素の検索にin 演算子（2 in [1,2,3] のような使い方をする演算子。
詳細については8 章を参照）を使用するようコードを書き直す。
d. [] の中に要素を直接書き込む、という方法でリストを作成するのをやめ、for ループとリストの
append メソッドを使用して、プログラム実行時に2 のべき乗のリストL が作成されるよう、コー
ドを書き直す。

## まとめ演習
----------------------

### 簡単な関数
VSCodeのセルで、まず「引数を1 つ受け取り、それを画面に出力する」という関数のコード
を書いてください。関数ができたら、次に、引数を指定してその関数を呼び出します。引数の種類を、
文字列、整数、リスト、ディクショナリ……というように様々に変えて、実行結果がどのように変わ
るかを確かめてください。また、引数を指定しなかった場合、引数を2 つ指定した場合の実行結果も
確かめてください。

### 2つの引数
モジュールファイルに、「2 つの引数を受け取り、両者を足し合わせた（あるいは連結した）結果を
戻す」という関数のコードを入力してください。関数の名前はadder とします。関数のコードが入
力できたら、（同一ファイル内の）その後に関数を呼び出すコードも追加します。呼び出しのコード
は1 つではなく、引数の種類を様々に変えて（文字列2 つ、リスト2 つ、浮動小数点数2 つ、など）い
くつも書いてください。コードがすべて入力できたら、システムのコマンドラインでプログラムを実
行します。関数呼び出しのコードをVSCodeのセルでの場合と同じように書いていては、関数の
実行結果が画面に出力されない場合があるので注意してください。

### 引数の数を増やす（減らす）
演習2 で作成したadder 関数を、汎用性を高めるため、指定する引数の数を呼び出し時に自由に決め
られるように改造してください（ヒント：これには、まずS[:0] というようなスライシングのコー
ドとビルトイン関数typeを組み合わせる、という方法が考えられます。S[:0]はSと同じ型の空のシー
ケンスを戻すコード、type 関数は指定のオブジェクトの型を確認するための関数です。あるいは、
16 章で紹介したmin1 関数のような方法も使えます。後者の方がアプローチとしては簡単でしょう）。
改造ができたら、呼び出しのコードにも変更を加え、指定する引数の数を2 より少なく、あるいは多
くしてみてください。
引数の型を様々に変え、実行結果の型がどのように変わるかも確かめてください。また、異なる型の
引数を混在させた場合、あるいはディクショナリを引数に指定した場合にどのような結果が得られる
かも確かめてみましょう。

### キーワード引数
演習2のadder関数を、 「3つの引数を受け取り、合計する、あるいは連結する」というものに変えます（引
数名はgood、bad、ugly にします）。個々の引数にはあらかじめデフォルト値を設定してください。
改造ができたら、関数を呼び出すコードも書きます。引数の数を1 つ、2 つ、3 つ、4 つ……と様々
に変えて呼び出す他、キーワード引数を使用した呼び出しも試してみましょう。adder(ugly=1,
good=2) というような呼び出しコードは正しいでしょうか。正しい（あるいは正しくない）理由も
考えてください。引数の違いによる実行結果の変化をひととおり確かめたら、adder 関数をさらに改
造して、キーワード引数を任意の数だけ指定できるようにしてみましょう。演習3 での改造に似てい
ますが、呼び出し時に指定される引数がタプルではなく、ディクショナリに収められる点が異なりま
す（ヒント：ディクショナリのkeys メソッドを使用すると、キーのリストが得られます。for ループ、
while ループを使えば、このリストの個々の要素に順にアクセスすることができます）。

### ディクショナリのコピー
ディクショナリを引数として受け取ると、それをコピーする、という関数を作ってください。関数名
はcopyDict とします。「コピーする」というのは、元のディクショナリとまったく同様の要素で構
成されるディクショナリを新たに作る、ということを意味します。ディクショナリの要素に順にアク
セスするにはkeys メソッドを利用します。シーケンスのコピーには、
X[:] というようなコードが使用できますが、ディクショナリにもこのようなコードが使用できるで
しょうか。

### ディクショナリの和集合
2 つのディクショナリの和集合を求めるaddDict という関数を作ってください。2 つのディクショナ
リを引数として呼び出すと、少なくともいずれか一方のディクショナリに属している要素をすべて含
む新たなディクショナリが作成される、というものにします。両方のディクショナリに共通のキーが
あった場合には、どちらかのディクショナリ（どちらでもかまいません）から値が選ばれるようにし
てください。引数としてディクショナリではなくリストを指定するとどうなるかも確かめるようにし
ます。addDict をあらゆる型の引数に対応できる関数にするにはどうすればよいでしょうか（先述
のtype 関数が使えないかを考えてみてください）。その他、引数の指定順序によって結果が変わる
かも確かめてみましょう。

### 引数のバリエーション
まず、以下の6 つの関数のコードをVSCodeのセルでかモジュールファイルに入力します。

```python
def f1(a, b): print a, b # 通常の引数
def f2(a, *b): print a, b # 引数の数を自由に変えられる
def f3(a, **b): print a, b # 引数の数を自由に変えられる（キーワード引数）
def f4(a, *b, **c): print a, b, c # * と** の混在
def f5(a, b=2, c=3): print a, b, c # デフォルト値の設定
def f6(a, b=2, *c): print a, b, c # 通常の引数、* 、デフォルト値の混在
```

関数のコードが入力できたら、VSCodeのセルで以下のように関数を呼び出し、個々の実行結
果がなぜそのようになったのかを考えてください。わからない場合は、16 章の引数のバリエーショ
ンに関する説明を読み返してみるとよいでしょう。1 つの関数に複数種の引数を混在させるのは一般
に得策と言えるでしょうか。また、複数種の引数を混在させた方がよいのは、具体的にはたとえばど
のような関数でしょうか。

```python
>>> f1(1, 2)
>>> f1(b=2, a=1)
>>> f2(1, 2, 3)
>>> f3(1, x=2, y=3)
>>> f4(1, 2, 3, x=2, y=3)
>>> f5(1)
>>> f5(1, 4)
>>> f6(1)
>>> f6(1, 3, 4)
```

### 素数
以下のようなコードは、簡単に言うと、正の整数y が素数であるか否かを確かめるコードです。

```python
# x = y / 2 # y は1 より大きい整数
while x > 1:
    if y % x == 0: # 余りが0 かを確かめる
        print (y, 'has factor' , x)
        break # else ブロックは実行しない
    x = x-1
else: # break が実行されなければelse ブロックを実行
    print(y, 'is prime')
```

上記のコードをモジュールファイルに入力し、関数に改造してください。それができたら、関数のコー
ドの後に、関数を呼び出すためのコードをいくつか追加します。コードの実行後は、浮動小数点数が
引数として指定された場合にも対応できるよう、/ を// に変えるという改造も行ってください。5 章
で述べたとおり、/ の仕様は今後（おそらくPython 3.0 で）変わる予定ですが、この改造をしておけ
ば、仕様が変更されても関数が機能しなくなる恐れはありません。その他、引数が負の数、0 あるい
は1 であった場合に対応するにはどうすればよいか、関数の実行速度を上げるにはどうすればよいか、
といったことについても考えてみてください。関数の実行結果は、以下のようなものになるはずです。

```shell
13 is prime
13.0 is prime
15 has factor 5
15.0 has factor 5.0
```

### リスト内包表記
[2, 4, 9, 16, 25] というリストの各要素の平方根を求め、その平方根を要素とする新たなリスト
を作成する、というコードを書いてください。まずはfor ループを使い、次にmap 関数、その次にリ
スト内包表記を使って書くようにします。3 つの方法のうちどれが最も自分に合っているかも考えて
みてください。平方根を求める計算には、math というビルトインモジュールのsqrt という関数が使
用できます（そのためには、math モジュールをインポートし、math.sqrt(x) というようなコード
を書く必要があります）。


## まとめ演習
-----------------------

1. 簡単なモジュールファイルのインポート
「指定のファイルに含まれる行数、文字数をカウントする」という機能を備えたプログラム（UNIX
のwc と同じようなものです）を作成してください。プログラムのコードは、テキストエディタを使
用し、mymod.py というモジュールファイルに入力します。このモジュールファイルは、次の3 つの
属性（関数）を持つものにします。

countLines(name)
引数に名前を指定されたファイルの内容を読み取り、中に含まれる行の数をカウントする関数で
す（ヒント：file.readlines メソッドとlen 関数を使用すれば、主な処理のほとんどは自動
的に行われます）。

countChars(name)
引数に名前を指定されたファイルの内容を読み取り、中に含まれる文字の数をカウントする関数
です（ヒント：ファイル全体の内容を1つの文字列として戻すfile.readメソッドを使用します）。

test(name)
上記2 つの関数を呼び出す関数です。この関数の引数として指定されたファイル名が、そのまま
2 つの関数の引数として使用されます。ファイル名は、raw_input 関数やsys.argv 属性を利用
すれば、プログラム実行時にユーザに入力させることもできます。ただ、ここでは、関数を呼び
出すコードの中で指定できればよい、ということにします。

3つの関数の引数はいずれも「ファイル名（文字列）」です。どの関数も、2、3 行のコードを書けば
できるはずです。ヒントの部分もよく読むようにしてください。
モジュールファイルができたらVSCodeのセルで機能を確認します。まずモジュールを
import ステートメントでインポートし、. を使用した形式でそれぞれの関数を呼び出します。場合
によっては、mymod.py モジュールの置かれているディレクトリをPYTHONPATH 変数に指定しなけれ
ばならない場合もあります。test("mymod.py") のように、mymod.py モジュール自身を引数とした
場合にどうなるかも確認してください。おそらくtest 関数は、結果的にopen 関数を2 回呼び出すよ
うなものになる（しかも2 回とも同じファイルを引数にすることになる）と思いますが、意欲があれば、
open 関数の呼び出しが1 回で済むように改良してみてください（ヒント：test 関数を、「まずopen
関数を呼び出し、戻り値として得られるファイルオブジェクトを引数にして2 つの関数を呼び出す」
というものにします。2 つの関数の中では、file.seek(0) と書けばファイルの先頭からアクセスす
ることができます）。

### from ステートメント
演習1 で作ったmymod モジュールの関数を、VSCodeのセルで実行してください。ただし、イ
ンポートにはimport ステートメントは使用せず、from ステートメントを使用します。関数を1 つず
つインポートする他、from * ステートメントですべての関数を一度にインポートする、という方法
も試してみてください。

### __name__属性
mymod.py モジュールファイルに、このモジュールがトップレベルファイルとして使用された場合に
のみ実行される（モジュールがインポートされた場合には実行されない）コードを追加してください。
このコードでは、test 関数を呼び出すようにします。モジュールがトップレベルファイルとして使
用されているかどうかは、__name__属性の値が文字列"__main__" となっているかどうかによって
確認するとよいでしょう。コードの追加ができたら、まずシステムのコマンドラインでモジュールを実行
し、次にVSCodeのセルでモジュールをインポートして個々の関数を呼び出します。追加したコード
に間違いがなければ、いずれの場合もモジュールは問題なく機能するはずです。

### ネストインポート
mymod モジュールをインポートし、その関数を利用するmyclient.py というモジュールを作ってくだ
さい。インポートにfrom ステートメントを使用したバージョンと、import ステートメントを使用
したバージョンの両方を作ります。myclient モジュールができたら、システムのコマンドラインで
実行し、両方のバージョンについて正しく動作するかを確認してください。また、対話型コマンドラ
インで両方のバージョンのmyclient モジュールをインポートし、__dict__属性の値を調べてください。

### パッケージインポート
まず、モジュールサーチパスに含まれているディレクトリのいずれかにmypkg という名前のディレ
クトリを作り、演習1～3 で作ったmymod.py モジュールファイルをそのディレクトリに移してくだ
さい。そして、mymod.py モジュールをimport mypkg.mymod というコードでパッケージインポー
トします。
import mypkg.mymod というコードは主なプラットフォームであればどれでも問題なく機能するは
ずです（. を使ってディレクトリパスを指定するのは、コードが特定のプラットフォームに依存し
ないようにするためでもあります）。mymod.py モジュールの移動先のディレクトリには
__init__.pyファイルを追加しなければならない、という点にも注意をしてください（__init__.py ファイルに何
かコードを書いて、それがパッケージインポートのたびに実行されることも確認してみてください）。
mypkg がカレントの作業ディレクトリのサブディレクトリであれば、モジュールサーチパスの設定
作業はまったく不要になります。カレントの作業ディレクトリ（ホームディレクトリ）は最初からモ
ジュールサーチパスに含まれているからです。

### リロード
changer.pyモジュールをVSCodeのセルでインポートし、内容に変更（例：メッセージを変える、関数の機能を変える、など）を加
えた後でリロードをしてみてください。その間、VSCodeのセルでは一度も終了させません。使
用するシステムによって、モジュールファイルの編集をVSCodeのセルでと別のウィンドウで行
う場合もあれば、VSCodeのセルでと同じウィンドウで行う場合もあります（UNIX では、実行
中のプロセスをCtrl-Z で一時停止し、fg コマンドによって再開する、ということができます。対話型
コマンドラインと同じウィンドウで編集を行う場合は、この方法でコマンドラインのプロセスを一時
停止します）。

```python changer.py
message = "First version"
def printer():
    print message
```


### 循環インポート†
「*** 再帰インポート ***」では、import recur1 というコードはエラーになっていま
した。しかし、VSCodeのセルをいったん終了してからimport recur2 を実行すると、エ
ラーにはなりません。自分で実際にコードを書いて実行し、この現象が起きることを確認してくださ
い。import recur1 がエラーになるのに、import recur2 がエラーにならないのはなぜでしょう
か（ヒント：新たにインポートされたモジュールは、コードが実行される前にビルトイン属性sys.
modules の値であるディクショナリに収められ、2 回目以降のインポートでは、このディクショナリ
からモジュールが抽出されます。たとえ、モジュールが「不完全」なものであっても、この点は変わ
りません）。% python recur1.py というように、recur1 モジュールをトップレベルファイルとし
て実行した場合にも同じエラーは発生するでしょうか。どちらにしてもその理由を考えてください（ヒ
ント：recur1 がインポートされるのではなく、トップレベルファイルとして実行された場合には、
recur2 をVSCodeのセルでインポートしたのと同じ結果になります。このとき、最初にイン
ポートされるモジュールはrecur2 です）。recur2 モジュールをトップレベルファイルとして実行し
た場合にどうなるでしょうか。

````python recur1.py
# recur1.py ファイル
X = 1
import recur2 # recur2 モジュールが（実行済みでなければ）実行される
Y = 2
```
```python recuur2.py
# recur2.py ファイル
from recur1 import X  # 正しい：変数X にはすでに値が代入されている
from recur1 import Y  # 誤り：変数Y にはまだ値が代入されていない
````

## まとめ演習
-------------------------

```python
################################################
# Lister はミックスインクラス。__repr__メソッド
# は、インスタンスの文字列への変換を必要とする
# あらゆるクラスで継承して利用できる。
# self は最下位クラスのインスタンス。
################################################
class Lister:　
　　def　__repr__(self):
        return ("<Instance of %s, address %s:\n%s>" % 
                                          (self. __class__ . __name__, # インスタンスのクラス名
                                          id(self), # インスタンスのアドレス
                                          self.attrnames()) ) # 属性と値のリスト

   def attrnames(self):
       result = ''
       for attr in self.__dict__.keys(): #__dict__はインスタンスの名前空間
           if attr[:2] == '__':
               result = result + "\tname %s=<built-in>\n" % attr
           else:
               result = result + "\tname %s=%s\n" % (attr, self.__dict__[attr])
       return result
```

### 継承
add(self, x, y)というメソッドを持つ、 Adderというクラスを作成してください。addメソッドは、
“Not Implemented”というメッセージを出力するだけのものにします。その後、Adder のサブクラ
スを以下のように2 つ作成してください。その両方でadd メソッドをカスタマイズします。

ListAdder
add メソッドは、「引数として2 つのリストを指定すると、両者を連結して戻す」というものに
します。

DictAdder
add メソッドは、「引数として2 つのディクショナリを指定すると、両者の要素を併せ持つ新た
なディクショナリを作成して戻す」というものにします（その具体的な方法は問いません）。

3つのクラスのコードが書けたら、VSCodeのセルでそれぞれのインスタンスを作り、add メ
ソッドを呼び出します。
それができたら、Adder クラスを改造します。まず、
__init__メソッド（コンストラクタ）を作り、インスタンス属性（self.data）にリストかディクショナリを代入する機能を持たせます。次
に、__add__メソッドを使って+ 演算子をオーバーロードします。これで、Adder のインスタンスが+ を使った演算に使用された場合には、自動的に
__add__メソッドが呼び出されるようになります（X + Y と書けば、X.add(X.data, Y) が自動的に呼び出される、など）。この場合、Adder は、
__init__メソッド、__add__メソッドを持たせるクラスとして適当でしょうか。+ 演算でAdderのインスタンスとともに使用できるのはどのようなオブジェクトでしょうか。
add メソッドの引数（self を除く引数）は2 つではなく、1 つにする方が簡単です（add(self, y)
のようにします）。この場合、add メソッドの中では、インスタンス属性に保持された値と、引数と
して渡された値との連結（self.data + y）を行うことになります。この方法は、引数を2 つにす
る方法に比べてメリットが多いと言えますか。また、クラスをより「オブジェクト指向的」にできる
方法と言えますか。

### リストの機能のオーバーロード
ビルトインオブジェクトである「リスト」をインスタンス属性の値として組み込み、リストの機能を
オーバーロードするクラスMylist を作成してください。このクラスには、リストの持つ、+ 演算、
インデクシング、反復処理、スライシング、メソッド（例：append、sort）などの機能を持たせます。
その他、リストにどのような機能があるかは、Python のリファレンスマニュアルで調べてください。

Mylist クラスには、リストの機能をオーバーロードするためのメソッドに加え、インスタンス作成
時にリストをインスタンス属性の値として組み込むための
__init__メソッドも必要です。Mylist
クラスの「呼び出し」時に引数に指定されたリストをインスタンス属性にコピーするようにしてもよ
いでしょう。Mylist クラスのコードが書けたら、VSCodeのセルで機能を確かめます。この
演習では、特に次の点についてよく考えるようにしてください。

a. インスタンス作成時に引数に指定されたリストを、インスタンス属性にそのまま代入せず「コ
ピー」するのはなぜか。
b. リストをインスタンス属性にコピーするのに、インデックスを指定しないスライシングのコード
（start[:] など）は使用できるか。
c. 1 つのフックメソッドでリストの複数のメソッドに対応する、ということはできるか。
d. Mylist + < リスト> あるいは< リスト> + Mylist という演算はできるか。
e. Mylist を使った+ 演算、スライシング、インデクシングでは、結果としてどのようなオブジェ
クトが得られるようにすべきか。
f. Python 2.2 以降を使用していれば、インスタンス属性にリストを組み込む以外に、リストのサブ
クラスを作るという方法でも同様のことができる。どちらの方法が容易か、また、その理由は？

### サブクラスの作成
演習2 のMylist のサブクラスMylistSub を作成します。このサブクラスには、演算子オーバーロー
ドのためのフックメソッドが呼び出されるたびにstdout にメッセージを出力する機能、そして、フッ
クメソッドの呼び出し回数をカウントする機能などを持たせます。MylistSubでは、 Mylistのメソッ
ドの基本的な機能はそのまま継承します。その上で、+ 演算などの際にメッセージの出力、カウンタ
のインクリメントを行う機能を追加するのです。その他、カウンタの内容をstdout に出力するため
の新たなメソッドも追加します。MylistSub クラスができたら、VSCodeのセルで機能を確
認してください。カウンタは、インスタンスごとに設けることもできますが、MylistSub のインス
タンスすべてについてフックメソッドの呼び出し回数をカウントするようなカウンタも作れます。両
方のカウンタをクラスに同時に持たせるとしたら、どのようにコードを書けばよいでしょうか（ヒン
ト：カウンタをクラス属性にするか、インスタンス属性にするかで、そのカウンタの性質が変わりま
す。クラス属性なら全インスタンスに共有されますが、インスタンス属性はインスタンスごとに作ら
れます）。

### Meta クラス
属性へのアクセス（値の抽出、値の設定）に対応するフックメソッドを備えたMeta というクラスを
作成します。フックメソッドには、アクセス対象の属性の名前、属性に設定される値などをstdout
に出力する機能を持たせます。Metaクラスができたら、VSCodeのセルでインスタンスを作り、
機能を確認します。属性へのアクセスのコードだけでなく、+ 演算、インデクシング、スライシング
などのコードにもMeta のインスタンスを使用し、どのような結果が得られるかを確かめてみてくだ
さい。


### Set クラス
「26.1.1 デリゲーションによる拡張」に載せたSet クラスをVSCodeのセルで使用し、以下の
作業を行ってください。

a. 整数の集合を2 つ作成し、& 演算、| 演算によって、両者の共通集合、和集合を求める。
b. 文字列を基に文字の集合を作成し、その集合に対してインデクシングを行う。また、この場合に
Set クラスのどのメソッドが呼び出されるかを考える。
c. b と同じ集合に対し、for ループを使用して反復処理を行う。また、この場合についても、Set
クラスのどのメソッドが呼び出されるかを考える。
d. b の集合と通常の文字列との共通集合、和集合を求める演算を試み、正しく演算が行われるかど
うかを確かめる。
e. Set のサブクラスを作成する。その際、
* 記号を使用して、引数の数を自由に変えられるように、
メソッドをカスタマイズする（ヒント：16 章では、同様の機能を持った関数を紹介している）。
サブクラスができたら、それを使用して、3 つ以上の集合の共通集合、和集合を求める演算を行
う（この場合、&、| は使用できない点に注意）。
f. Set クラスに、「リスト」としての機能をさらに追加する（ヒント：たとえば、連結の処理には
__add__メソッドで対応できる。__getattr__メソッドを使用すれば、実際の処理の多くをリストに「委託」するということも可能）。

### __bases__属性
クラスには__bases__という属性があります。この属性の値は、そのクラスのスーパークラス（クラス
オブジェクト）を要素とするタプルです（つまり、class ステートメントの見出し行のカッコに指定
されたスーパークラスが要素になります）。ここでは、この
__bases__属性を使用して、**** Lister クラス *** に「直接のスーパークラスの名前を出力する」という機能を追加してください。
Lister を継承したサブクラスのインスタンスを（print などで）文字列変換したとき、1 行目が以
下のようになればよいでしょう（アドレスの部分はこのとおりにはなりません）。

```shell
<Instance of Sub(Super, Lister), address 7841200:
```

この後にスーパークラスの属性のリストも表示されるようにするにはどうすればよいでしょうか（ヒ
ント：クラスの
__dict__属性を使用します）。また、直接のスーパークラスだけでなく、アクセス
可能なすべてのスーパークラスの名前とその属性のリストを出力する機能をLister に追加するには
どうすればよいかも考えてみてください。「スーパークラスのスーパークラスを調べ、さらにそのスー
パークラスを調べる……」という処理をどのように行えばよいかは、24 章のclasstree.py モジュール
のコードを見ればわかるでしょう。25 章の「25.6 多重継承」の脚注でも触れたとおり、Python 2.2
以降なら、この処理にdir、getattr といった関数が使えます。

### コンポジション
ファーストフード店をシミュレートするプログラムを作ります。このプログラムは、以下の4 つのク
ラスから構成されるものとします。

Lunch
他のクラスの「コンテナ」、「コントローラ」として機能するクラス
Customer
商品を購入する「顧客」に対応するクラス
Employee
顧客からの注文を受ける「従業員」に対応するクラス
Food
顧客が購入する「商品」に対応するクラス

ヒントとして、以下に、それぞれのクラスに持たせるべきメソッドを示しておきます。

```python
class Lunch:
   def __init__(self) # Customer、Employee のインスタンスを組み込む
   def order(self, foodName) # 顧客による「注文」のシミュレーションを開始する
   def result(self) # 顧客が購入した商品の名前を出力する

class Customer:
   def __init__(self) # 「顧客」を初期化して商品購入前の状態にする
   def placeOrder(self, foodName, employee) # Employee に商品を注文する
   def printFood(self) # 購入した商品の名前を出力する

class Employee:
    def takeOrder(self, foodName) # 注文された商品の名前を属性として持った

# Food インスタンスを戻す
class Food:
    def __init__(self, name) # 注文された商品の名前を保持する
```

プログラムのおおまかな使い方、動きは以下のとおりです。

a. まず、Lunch クラスのインスタンスを作る。その際、Lunch クラスの
__init__メソッド（コンストラクタ）では、Customer クラスとEmployee クラスのインスタンスが作られ、Lunch の
インスタンス属性の値として組み込まれる。次に、Lunchのインスタンスを使用してorderメソッ
ドを呼び出す。order メソッドの中では、
__init__で組み込んだCustomer のインスタンスを使用し、placeOrder メソッドが呼び出される。order メソッドは、店での商品の受注をシミュ
レーションするためのメソッドで、引数としては注文される商品名を指定する。order メソッド
から呼び出されるplaceOrder メソッドでは、さらにEmployee クラスのtakeOrder メソッド
が呼び出される。

b. takeOrder メソッドはFood クラスのインスタンスを戻すが、このインスタンスは、注文された
商品の名前（“burritos
”など）を属性として保持する。この商品名は、Customer.placeOrder
からEmployee.takeOrder、そしてFood クラスのコンストラクタ（__init__メソッド）へと渡される。商品名がFood のインスタンスに保持されたら、次はLunch クラスのresult メソッ
ドを呼び出す。このメソッドでは、Customer クラスのprintFood メソッドが呼び出される。
printFood メソッドでは、takeOrder メソッドの戻り値として受け取ったFood インスタンス
を利用して、注文された商品の名前を出力する（result メソッドはプログラムが正しく機能し
ているかをテストするためのメソッドとしても使える）。

Lunch クラスのコードでは、Customer のインスタンスに、Lunch 自身のインスタンスとともに
Employee のインスタンスを渡さねばならない、という点に注意してください。これは、Customer
からさらにEmployee のメソッドを呼び出すことになるからです。
4 つのクラスができたら、VSCodeのセルで実行し、機能を確認します。その際は、まず、ク
ラス名Lunch をモジュールからインポートして、Lunch のインスタンスを作成し、次に、引数に商
品名を指定してorder メソッドを呼び出します。それができたら、result メソッドを呼び出して、
商品名が正しくCustomer、Employee のインスタンスに伝わっていることを確認します。モジュー
ルの最後に、トップレベルで使用された際に実行されるコードを入れておけば、テストのたびにイ
ンスタンス作成のコードやメソッド呼び出しのコードを入力する、という手間が省けます（これに
は__name__属性を使用します。詳しくは21 章を参照してください）。ここでは、プログラムを、
Customer のメソッドからEmployee メソッドが呼び出される、という構造にします。つまり、 「顧客」
が注文を出すと、それを「従業員」が受ける、という「顧客主体」の構造にするわけです。これを、
「従業員」が注文を聞くと、それに「顧客」が応える、という「従業員主体」の構造にするとしたら、
プログラムのコードはどのように変える必要があるかを考えてみてください。